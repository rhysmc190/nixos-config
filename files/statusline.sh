#!/usr/bin/env bash
# Generated by cc-statusline v1.3.2 (https://www.npmjs.com/package/@chongdashu/cc-statusline)
# Custom Claude Code statusline - Created: 2025-12-12T11:48:00.928Z
# Simplified and optimized version
STATUSLINE_VERSION="2.0.0"

# ---- Configuration ----
# Feature toggles
SHOW_GIT_STATUS=true       # Show âœ“/â— git clean/dirty indicator
SHOW_MODEL_VERSION=true    # Show model version number
SHOW_TIME=true             # Show current time

# Display settings
MAX_DIR_LENGTH=30          # Max chars for directory path
MAX_BRANCH_LENGTH=20       # Max chars for git branch name
PROGRESS_BAR_WIDTH=10      # Width of progress bars

input=$(cat)

# Get the directory where this statusline script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_FILE="${SCRIPT_DIR}/statusline.log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# ---- check jq availability ----
HAS_JQ=0
if command -v jq >/dev/null 2>&1; then
  HAS_JQ=1
fi

# ---- logging ----
{
  echo "[$TIMESTAMP] Status line triggered (cc-statusline v${STATUSLINE_VERSION})"
  echo "[$TIMESTAMP] Input:"
  if [ "$HAS_JQ" -eq 1 ]; then
    echo "$input" | jq . 2>/dev/null || echo "$input"
    echo "[$TIMESTAMP] Using jq for JSON parsing"
  else
    echo "$input"
    echo "[$TIMESTAMP] WARNING: jq not found, using bash fallback for JSON parsing"
  fi
  echo "---"
} >> "$LOG_FILE" 2>/dev/null

# ---- utility functions ----
# Truncate string with ellipsis, preserving end (most important for paths)
truncate() {
  local str="$1"
  local max_len="$2"
  local str_len=${#str}

  if [ "$str_len" -le "$max_len" ]; then
    echo "$str"
  else
    # Keep the end of the string (most important for paths like ~/project/subdir)
    local keep=$((max_len - 3))
    local start=$((str_len - keep))
    echo "...${str:$start}"
  fi
}

# Make path relative to project root
# Example: ~/dev/website-monorepo/internal/app -> website-monorepo/internal/app
make_project_relative() {
  local path="$1"

  # Expand ~ to $HOME for processing
  local expanded_path="${path/#\~/$HOME}"

  # If in a git repo, use git root as project root
  if git -C "$expanded_path" rev-parse --show-toplevel >/dev/null 2>&1; then
    local git_root=$(git -C "$expanded_path" rev-parse --show-toplevel 2>/dev/null)
    local project_name=$(basename "$git_root")

    # Get relative path from git root
    local rel_path="${expanded_path#$git_root}"
    rel_path="${rel_path#/}"  # Remove leading slash

    # Combine project name with relative path
    if [ -n "$rel_path" ]; then
      echo "${project_name}/${rel_path}"
    else
      echo "${project_name}"
    fi
  else
    # Not in a git repo, just return the basename
    echo "$(basename "$expanded_path")"
  fi
}

# ---- color helpers (force colors for Claude Code) ----
use_color=1
[ -n "$NO_COLOR" ] && use_color=0

C() { if [ "$use_color" -eq 1 ]; then printf '\033[%sm' "$1"; fi; }
RST() { if [ "$use_color" -eq 1 ]; then printf '\033[0m'; fi; }
rst() { RST; }  # Alias for consistency

# ---- modern sleek colors ----
dir_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;117m'; fi; }    # sky blue
model_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;147m'; fi; }  # light purple
version_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;180m'; fi; } # soft yellow
cc_version_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;249m'; fi; } # light gray
style_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;245m'; fi; } # gray
git_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;150m'; fi; }  # soft green
git_clean_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;82m'; fi; }  # bright green
git_dirty_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;208m'; fi; }  # orange
context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[1;37m'; fi; }  # default white

# ---- time helpers ----
to_epoch() {
  ts="$1"
  if command -v gdate >/dev/null 2>&1; then gdate -d "$ts" +%s 2>/dev/null && return; fi
  date -u -j -f "%Y-%m-%dT%H:%M:%S%z" "${ts/Z/+0000}" +%s 2>/dev/null && return
  python3 - "$ts" <<'PY' 2>/dev/null
import sys, datetime
s=sys.argv[1].replace('Z','+00:00')
print(int(datetime.datetime.fromisoformat(s).timestamp()))
PY
}

fmt_time_hm() {
  epoch="$1"
  if date -r 0 +%s >/dev/null 2>&1; then
    date -r "$epoch" +"%H:%M"
  else
    date -d "@$epoch" +"%H:%M"
  fi
}

progress_bar() {
  pct="${1:-0}"; width="${2:-$PROGRESS_BAR_WIDTH}"
  [[ "$pct" =~ ^[0-9]+$ ]] || pct=0
  ((pct<0))&&pct=0; ((pct>100))&&pct=100
  filled=$(( pct * width / 100 )); empty=$(( width - filled ))
  printf '%*s' "$filled" '' | tr ' ' '='
  printf '%*s' "$empty" '' | tr ' ' '-'
}

# ---- JSON extraction utilities ----
# Pure bash JSON value extractor (fallback when jq not available)
extract_json_string() {
  local json="$1"
  local key="$2"
  local default="${3:-}"

  # For nested keys like workspace.current_dir, get the last part
  local field="${key##*.}"
  field="${field%% *}"  # Remove any jq operators

  # Try to extract string value (quoted)
  local value=$(echo "$json" | grep -o "\"\${field}\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" | head -1 | sed 's/.*:[[:space:]]*"\([^"]*\)".*/\1/')

  # Convert escaped backslashes to forward slashes for Windows paths
  if [ -n "$value" ]; then
    value=$(echo "$value" | sed 's/\\\\/\//g')
  fi

  # If no string value found, try to extract number value (unquoted)
  if [ -z "$value" ] || [ "$value" = "null" ]; then
    value=$(echo "$json" | grep -o "\"\${field}\"[[:space:]]*:[[:space:]]*[0-9.]\+" | head -1 | sed 's/.*:[[:space:]]*\([0-9.]\+\).*/\1/')
  fi

  # Return value or default
  if [ -n "$value" ] && [ "$value" != "null" ]; then
    echo "$value"
  else
    echo "$default"
  fi
}

# ---- basics ----
if [ "$HAS_JQ" -eq 1 ]; then
  current_dir=$(echo "$input" | jq -r '.workspace.current_dir // .cwd // "unknown"' 2>/dev/null | sed "s|^$HOME|~|g")
  model_name=$(echo "$input" | jq -r '.model.display_name // "Claude"' 2>/dev/null)
  model_version=$(echo "$input" | jq -r '.model.version // ""' 2>/dev/null)
  session_id=$(echo "$input" | jq -r '.session_id // ""' 2>/dev/null)
  cc_version=$(echo "$input" | jq -r '.version // ""' 2>/dev/null)
  output_style=$(echo "$input" | jq -r '.output_style.name // ""' 2>/dev/null)
else
  # Bash fallback for JSON extraction
  # Extract current_dir from workspace object
  current_dir=$(echo "$input" | grep -o '"workspace"[[:space:]]*:[[:space:]]*{[^}]*"current_dir"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"current_dir"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' | sed 's/\\\\/\//g')

  # Fall back to cwd if workspace extraction failed
  if [ -z "$current_dir" ] || [ "$current_dir" = "null" ]; then
    current_dir=$(echo "$input" | grep -o '"cwd"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"cwd"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' | sed 's/\\\\/\//g')
  fi

  # Fallback to unknown if all extraction failed
  [ -z "$current_dir" ] && current_dir="unknown"
  current_dir=$(echo "$current_dir" | sed "s|^$HOME|~|g")

  # Extract model name from nested model object
  model_name=$(echo "$input" | grep -o '"model"[[:space:]]*:[[:space:]]*{[^}]*"display_name"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"display_name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  [ -z "$model_name" ] && model_name="Claude"
  model_version=""  # Not available in Claude Code JSON
  session_id=$(extract_json_string "$input" "session_id" "")
  cc_version=$(echo "$input" | grep -o '"version"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"version"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  output_style=$(echo "$input" | grep -o '"output_style"[[:space:]]*:[[:space:]]*{[^}]*"name"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
fi

# Store original dir for session file lookup (needs full path)
original_dir="$current_dir"

# Make path relative to project root, then truncate if needed
current_dir=$(make_project_relative "$current_dir")
current_dir=$(truncate "$current_dir" "$MAX_DIR_LENGTH")

# ---- git ----
git_branch=""
git_status_indicator=""
if git rev-parse --git-dir >/dev/null 2>&1; then
  git_branch=$(git branch --show-current 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
  git_branch=$(truncate "$git_branch" "$MAX_BRANCH_LENGTH")

  # Check if repo is clean or dirty (only if feature enabled)
  if [ "$SHOW_GIT_STATUS" = true ]; then
    if [ -z "$(git status --porcelain 2>/dev/null)" ]; then
      git_status_indicator="âœ“"  # clean
    else
      git_status_indicator="â—"  # dirty (uncommitted changes)
    fi
  fi
fi

# ---- context window calculation ----
context_pct=""
context_remaining_pct=0

# Determine max context based on model
get_max_context() {
  local model_name="$1"
  case "$model_name" in
    *"Opus 4"*|*"opus 4"*|*"Opus"*|*"opus"*)
      echo "200000"  # 200K for all Opus versions
      ;;
    *"Sonnet 4"*|*"sonnet 4"*|*"Sonnet 3.5"*|*"sonnet 3.5"*|*"Sonnet"*|*"sonnet"*)
      echo "200000"  # 200K for Sonnet 3.5+ and 4.x
      ;;
    *"Haiku 3.5"*|*"haiku 3.5"*|*"Haiku 4"*|*"haiku 4"*|*"Haiku"*|*"haiku"*)
      echo "200000"  # 200K for modern Haiku
      ;;
    *"Claude 3 Haiku"*|*"claude 3 haiku"*)
      echo "100000"  # 100K for original Claude 3 Haiku
      ;;
    *)
      echo "200000"  # Default to 200K
      ;;
  esac
}

if [ -n "$session_id" ] && [ "$HAS_JQ" -eq 1 ]; then
  MAX_CONTEXT=$(get_max_context "$model_name")

  # Convert original dir to session file path (needs full path, not project-relative)
  project_dir=$(echo "$original_dir" | sed "s|~|$HOME|g" | sed 's|/|-|g' | sed 's|^-||')
  session_file="$HOME/.claude/projects/-${project_dir}/${session_id}.jsonl"

  if [ -f "$session_file" ]; then
    # Get the latest input token count from the session file (only last 10 lines for speed)
    latest_tokens=$(tail -10 "$session_file" | jq -r 'select(.message.usage) | .message.usage | ((.input_tokens // 0) + (.cache_read_input_tokens // 0))' 2>/dev/null | tail -1)

    if [ -n "$latest_tokens" ] && [ "$latest_tokens" -gt 0 ]; then
      context_used_pct=$(( latest_tokens * 100 / MAX_CONTEXT ))
      context_remaining_pct=$(( 100 - context_used_pct ))

      # Set color based on remaining percentage
      if [ "$context_remaining_pct" -le 20 ]; then
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;203m'; fi; }  # coral red
      elif [ "$context_remaining_pct" -le 40 ]; then
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;215m'; fi; }  # peach
      else
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;158m'; fi; }  # mint green
      fi

      context_pct="${context_remaining_pct}%"
    fi
  fi
fi

# ---- usage colors ----
session_color() {
  rem_pct=$(( 100 - session_pct ))
  if   (( rem_pct <= 10 )); then SCLR='38;5;210'  # light pink
  elif (( rem_pct <= 25 )); then SCLR='38;5;228'  # light yellow
  else                          SCLR='38;5;194'; fi  # light green
  if [ "$use_color" -eq 1 ]; then printf '\033[%sm' "$SCLR"; fi
}

# ---- session info extraction ----
session_txt=""; session_pct=0; session_bar=""

# Get session info from ccusage if available
session_usage_pct=""
if command -v ccusage >/dev/null 2>&1 && [ "$HAS_JQ" -eq 1 ]; then
  blocks_output=""

  # Try ccusage with timeout for token data and session info
  if command -v timeout >/dev/null 2>&1; then
    blocks_output=$(timeout 5s ccusage blocks --json 2>/dev/null)
  elif command -v gtimeout >/dev/null 2>&1; then
    blocks_output=$(gtimeout 5s ccusage blocks --json 2>/dev/null)
  else
    blocks_output=$(ccusage blocks --json 2>/dev/null)
  fi

  if [ -n "$blocks_output" ]; then
    active_block=$(echo "$blocks_output" | jq -c '.blocks[] | select(.isActive == true)' 2>/dev/null | head -n1)
    if [ -n "$active_block" ]; then
      # Get projected total tokens to calculate usage percentage
      tot_tokens=$(echo "$active_block" | jq -r '.totalTokens // empty')
      projected_tokens=$(echo "$active_block" | jq -r '.projection.totalTokens // empty')

      # Calculate usage percentage if we have both values
      if [ -n "$tot_tokens" ] && [ -n "$projected_tokens" ] && [ "$projected_tokens" -gt 0 ]; then
        session_usage_pct=$(echo "$tot_tokens $projected_tokens" | awk '{printf "%.1f", ($1 / $2) * 100}')
      fi

      # Session time calculation from ccusage
      reset_time_str=$(echo "$active_block" | jq -r '.usageLimitResetTime // .endTime // empty')
      start_time_str=$(echo "$active_block" | jq -r '.startTime // empty')

      if [ -n "$reset_time_str" ] && [ -n "$start_time_str" ]; then
        start_sec=$(to_epoch "$start_time_str")
        end_sec=$(to_epoch "$reset_time_str")
        now_sec=$(date +%s)
        total=$(( end_sec - start_sec ))
        (( total<1 )) && total=1
        elapsed=$(( now_sec - start_sec ))
        (( elapsed<0 ))&&elapsed=0
        (( elapsed>total ))&&elapsed=$total
        session_pct=$(( elapsed * 100 / total ))
        remaining=$(( end_sec - now_sec ))
        (( remaining<0 )) && remaining=0
        rh=$(( remaining / 3600 ))
        rm=$(( (remaining % 3600) / 60 ))
        end_hm=$(fmt_time_hm "$end_sec")
        session_txt="$(printf 'Reset@%s %dh%02dm' "$end_hm" "$rh" "$rm")"
        session_bar=$(progress_bar "$session_pct" "$PROGRESS_BAR_WIDTH")
      fi
    fi
  fi
fi

# ---- log extracted data ----
{
  echo "[$TIMESTAMP] Extracted: dir=${current_dir:-} (original: ${original_dir:-}), model=${model_name:-}, git=${git_branch:-} ${git_status_indicator:-}, context=${context_pct:-}, session_usage=${session_usage_pct:-}%, session_pct=${session_pct:-}%"
  if [ "$HAS_JQ" -eq 0 ]; then
    echo "[$TIMESTAMP] Note: Context and session info require jq for full functionality"
  fi
} >> "$LOG_FILE" 2>/dev/null

# ---- render statusline ----
# Line 1: Model and current time
printf 'ðŸ¤– %s%s' "$(model_color)" "$model_name"
if [ "$SHOW_MODEL_VERSION" = true ] && [ -n "$model_version" ] && [ "$model_version" != "null" ]; then
  printf '  ðŸ·ï¸ %s' "$model_version"
fi
printf '%s' "$(rst)"
if [ "$SHOW_TIME" = true ]; then
  current_time=$(date '+%I:%M %p')
  printf '  ðŸ• %s' "$current_time"
fi

# Line 2: Core info (directory, git)
printf '\nðŸ“ %s%s%s' "$(dir_color)" "$current_dir" "$(rst)"
if [ -n "$git_branch" ]; then
  printf '  ðŸŒ¿ %s%s' "$(git_color)" "$git_branch"
  if [ "$SHOW_GIT_STATUS" = true ] && [ -n "$git_status_indicator" ]; then
    if [ "$git_status_indicator" = "âœ“" ]; then
      printf ' %s%s' "$(git_clean_color)" "$git_status_indicator"
    else
      printf ' %s%s' "$(git_dirty_color)" "$git_status_indicator"
    fi
  fi
  printf '%s' "$(rst)"
fi

# Line 3: Context remaining
line3=""
if [ -n "$context_pct" ]; then
  context_bar=$(progress_bar "$context_remaining_pct" "$PROGRESS_BAR_WIDTH")
  line3=$(printf 'ðŸ§  %sContext Remaining: %s  %s[%s]%s' "$(context_color)" "${context_pct}" "$(rst)" "${context_bar}" "$(rst)")
else
  line3=$(printf 'ðŸ§  %sContext Remaining: TBD%s' "$(context_color)" "$(rst)")
fi

# Line 4: Session usage analytics
line4=""
if [ -n "$session_usage_pct" ]; then
  # Convert to integer for progress bar and display
  session_usage_pct_int=$(echo "$session_usage_pct" | awk '{print int($1)}')
  session_usage_bar=$(progress_bar "$session_usage_pct_int" "$PROGRESS_BAR_WIDTH")

  # Color based on usage level
  if (( $(echo "$session_usage_pct >= 90" | bc -l) )); then
    usage_bar_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;203m'; fi; }  # red
  elif (( $(echo "$session_usage_pct >= 70" | bc -l) )); then
    usage_bar_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;215m'; fi; }  # orange
  else
    usage_bar_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;158m'; fi; }  # green
  fi

  line4=$(printf 'ðŸ“Š %sSession Usage Est: %d%%  %s[%s]%s' "$(usage_bar_color)" "$session_usage_pct_int" "$(rst)" "${session_usage_bar}" "$(rst)")
fi

# Line 5: Session time until reset
line5=""
if [ -n "$session_txt" ]; then
  # Format: "âŒ› Reset@03:00 2h17m: 54%  [====------]"
  line5=$(printf 'âŒ› %s%s: %d%%  %s[%s]%s' "$(session_color)" "${session_txt}" "$session_pct" "$(rst)" "${session_bar}" "$(rst)")
fi

# Print lines
if [ -n "$line3" ]; then
  printf '\n%s' "$line3"
fi
if [ -n "$line4" ]; then
  printf '\n%s' "$line4"
fi
if [ -n "$line5" ]; then
  printf '\n%s' "$line5"
fi
printf '\n'
